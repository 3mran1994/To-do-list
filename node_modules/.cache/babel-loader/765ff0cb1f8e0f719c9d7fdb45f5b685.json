{"ast":null,"code":"var _jsxFileName = \"/Users/imacqz/To-do-list/react-todo-app/src/App.js\",\n  _s = $RefreshSig$();\nimport React, { useState } from 'react';\nimport TodoList from './components/TodoList';\nimport AddTodo from './components/AddTodo';\nimport './styles/App.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst App = () => {\n  _s();\n  const [todos, setTodos] = useState([]);\n  const [editingIndex, setEditingIndex] = useState(null); // New state addition\n  const [previousTodos, setPreviousTodos] = useState(null); // Use state for undo feature.\n\n  const remainingTasks = todos.filter(todo => todo.completed === false).length; // todos is our master list (the array of all the tasks). .filter is a built in JS function that goes through the list one by one and checks if meets the conditions for it to stay or go (does it belong in the new list). For the contents of the filter function, todo (without the s) is the specific task on the list, todo.completed === false is the rule for the filter. if a task meets this condition, that it is not completed (false) then the filter will keep it in the list. If it is completed the filter will filter it out of the calculation. .length is a property of arrays that tells the count of how many items are inside tht array. So after the filter finishes it creates a new list of only the unfinished tasks and . length counts them and gives us the number.\n\n  const addTodo = todoText => {\n    //structure of this line is const x = (input from user) then => function/logic\n    setTodos([...todos, {\n      text: todoText,\n      completed: false\n    }]);\n  };\n  const editTodo = index => {\n    // adding the edit function\n    setEditingIndex(index);\n  };\n  const cancelEdit = () => {\n    // added the cancel function \n    setEditingIndex(null);\n  };\n  const removeTodo = index => {\n    const newTodos = todos.filter((_, i) => i !== index);\n    setTodos(newTodos);\n  };\n  const saveTodo = (index, newText) => {\n    // index is the \"postion\" of what task is changing and newText is what the new words are. Both of these are the parameters (inputs).\n    const newTodos = [...todos]; // this is the new copy of our list (todos is the orginial list). [...] is the spread operator that copies. We have to make a copy of the list to make changes to it instead of editing the original list and then we replace the old list (todos) with the new one (newTodos).\n    newTodos[index] = {\n      ...newTodos[index],\n      text: newText\n    }; // newTodos[index] is the index (position) of task in the newTodos list we created. the {} part is the new object we create and \"spread\" the old task's [...] onfo into it including the completed status. The (text: nexText) is just overwriting the text values with the new text but keeping the completion status of the list untouched. \n    setTodos(newTodos); // this is our setter function; how we will update our old list with our new changes. we are telling react to redraw the list so the user sees the new task (text).\n    setEditingIndex(null); // setter for our \"who is editing\" state. (null) is our value for nothing. this setter is for cleanup; to tell react that we are done editing and to close the input box and show the regular text again.\n  };\n  const toggleTodo = index => {\n    setTodos(todos.map((todo, i) => i === index ? {\n      ...todo,\n      completed: !todo.completed\n    } : todo));\n  };\n  const clearCompleted = () => {\n    // New addition. I added this on my own!\n    setPreviousTodos(todos); //Not my free hand addition. This step saves the backup list.\n    const newTodos = todos.filter(todo => todo.completed === false); //set variable newTodos with it's rules.\n    setTodos(newTodos); //replace setTodos with newTodos filtered above. This updates the list to the new list. \n  };\n  const undoClear = () => {\n    // No inputs need because we are just grabbing the backup we already have.\n    setTodos(previousTodos); // setting our master list to the \n    setPreviousTodos(null);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"app\",\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Todo List\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 58,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      children: [\"You have \", remainingTasks, \" \", remainingTasks === 1 ? \"task\" : \"tasks\", \" remaining\"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 59,\n      columnNumber: 13\n    }, this), \" \", /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: clearCompleted,\n      children: \"Clear Completed\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 60,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(AddTodo, {\n      onAdd: addTodo\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 61,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(TodoList, {\n      todos: todos,\n      removeTodo: removeTodo,\n      toggleTodo: toggleTodo,\n      editingIndex: editingIndex // New addition \n      ,\n      onEdit: editTodo // New addition\n      ,\n      onCancel: cancelEdit // New addition\n      ,\n      onSave: saveTodo //New addition\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 64,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 57,\n    columnNumber: 9\n  }, this);\n};\n_s(App, \"ocWivzO7wpenmh/LPvnko01cpZg=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","TodoList","AddTodo","jsxDEV","_jsxDEV","App","_s","todos","setTodos","editingIndex","setEditingIndex","previousTodos","setPreviousTodos","remainingTasks","filter","todo","completed","length","addTodo","todoText","text","editTodo","index","cancelEdit","removeTodo","newTodos","_","i","saveTodo","newText","toggleTodo","map","clearCompleted","undoClear","className","children","fileName","_jsxFileName","lineNumber","columnNumber","onClick","onAdd","onEdit","onCancel","onSave","_c","$RefreshReg$"],"sources":["/Users/imacqz/To-do-list/react-todo-app/src/App.js"],"sourcesContent":["import React, { useState } from 'react';\nimport TodoList from './components/TodoList';\nimport AddTodo from './components/AddTodo';\nimport './styles/App.css';\n\nconst App = () => {\n    const [todos, setTodos] = useState([]);\n    const [editingIndex, setEditingIndex] = useState(null); // New state addition\n    const [previousTodos, setPreviousTodos] = useState(null); // Use state for undo feature.\n\n    const remainingTasks = todos.filter (todo => todo.completed === false).length // todos is our master list (the array of all the tasks). .filter is a built in JS function that goes through the list one by one and checks if meets the conditions for it to stay or go (does it belong in the new list). For the contents of the filter function, todo (without the s) is the specific task on the list, todo.completed === false is the rule for the filter. if a task meets this condition, that it is not completed (false) then the filter will keep it in the list. If it is completed the filter will filter it out of the calculation. .length is a property of arrays that tells the count of how many items are inside tht array. So after the filter finishes it creates a new list of only the unfinished tasks and . length counts them and gives us the number.\n\n    const addTodo = (todoText) => { //structure of this line is const x = (input from user) then => function/logic\n        setTodos([...todos, { text: todoText, completed: false}]);\n    };\n\n    const editTodo = (index) => { // adding the edit function\n        setEditingIndex(index);\n    }; \n\n    const cancelEdit = () => { // added the cancel function \n        setEditingIndex(null);\n    };\n\n    const removeTodo = (index) => {\n        const newTodos = todos.filter((_, i) => i !== index); \n        setTodos(newTodos);\n    };\n\n    const saveTodo = (index, newText) => { // index is the \"postion\" of what task is changing and newText is what the new words are. Both of these are the parameters (inputs).\n        const newTodos = [...todos]; // this is the new copy of our list (todos is the orginial list). [...] is the spread operator that copies. We have to make a copy of the list to make changes to it instead of editing the original list and then we replace the old list (todos) with the new one (newTodos).\n        newTodos[index] = { ...newTodos[index], text: newText }; // newTodos[index] is the index (position) of task in the newTodos list we created. the {} part is the new object we create and \"spread\" the old task's [...] onfo into it including the completed status. The (text: nexText) is just overwriting the text values with the new text but keeping the completion status of the list untouched. \n        setTodos(newTodos); // this is our setter function; how we will update our old list with our new changes. we are telling react to redraw the list so the user sees the new task (text).\n        setEditingIndex(null); // setter for our \"who is editing\" state. (null) is our value for nothing. this setter is for cleanup; to tell react that we are done editing and to close the input box and show the regular text again.\n    };\n\n    const toggleTodo = (index) => {\n        setTodos(\n            todos.map((todo, i) =>\n                i === index ? { ...todo, completed: !todo.completed } : todo\n            )\n        );\n    };\n\n    const clearCompleted = () => { // New addition. I added this on my own!\n        setPreviousTodos(todos); //Not my free hand addition. This step saves the backup list.\n        const newTodos = todos.filter(todo => todo.completed === false); //set variable newTodos with it's rules.\n        setTodos(newTodos); //replace setTodos with newTodos filtered above. This updates the list to the new list. \n    };\n\n    const undoClear = () => { // No inputs need because we are just grabbing the backup we already have.\n        setTodos(previousTodos); // setting our master list to the \n        setPreviousTodos(null);\n    };\n\n    return (\n        <div className=\"app\">\n            <h1>Todo List</h1> \n            <p>You have {remainingTasks} {remainingTasks === 1 ? \"task\" : \"tasks\"} remaining</p> {/* we are referancing the variable remainingTasks in {} so that the text will show us the dynamic number of tasks remaining. The turnary operator sets the condition that if the amount of task (remainingTasks) is exactly equal to only 1 then print \"task\" singular in the paragraph, and if it does not equal 1 than print \"tasks\" in the paragraph. This allows us to have a set paragraph that can change dynamically */}\n            <button onClick={clearCompleted}>Clear Completed</button>\n            <AddTodo \n                onAdd={addTodo} \n            />\n            <TodoList \n                todos={todos} \n                removeTodo={removeTodo} \n                toggleTodo={toggleTodo} \n                editingIndex={editingIndex} // New addition \n                onEdit={editTodo} // New addition\n                onCancel={cancelEdit} // New addition\n                onSave={saveTodo} //New addition\n            />\n        </div>\n    );\n};\n\nexport default App;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}